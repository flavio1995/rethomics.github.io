[
["index.html", "Rethomics Tutorial Chapter 1 Introduction 1.1 The Rethomics workflow", " Rethomics Tutorial Quentin Geissmann 2017-08-23 Chapter 1 Introduction In the last few years the ability to acquire large amount of behavioural data from multiple individual experimental animal has increased. However, there are still very few tools that allows biologist to read, store, visualise and process data in a modular and consistant pipeline. The rethomics framework is a collection of R packages that work together in order to provide a programatic and efficient environment to analyse behavioural data. Since R is a state of the art software for scientific data visualisation and analysis, rethomics integrates in a its rich ecosystem of high-standard packages already available. This tutorial is intended for experimenters and data analysts and provided a suite of both theoritical explanations and very concrete examples of analysis. 1.1 The Rethomics workflow TODO figure "],
["intro.html", "Chapter 2 First Steps 2.1 Getting R 2.2 Installing rethomics packages 2.3 All our packages", " Chapter 2 First Steps 2.1 Getting R If you have never used or heard of R before, I suggest you start by reading about R and installing RStudio. Only once you have done can we continue. 2.2 Installing rethomics packages As of today (“2017-08-23”), rethomics packages are not on CRAN, the official R package archive yet. Therefore, we will install the developmental version. For that, we have to install (once for all) use devtools and load it: install.packages(&quot;devtools&quot;) library(devtools) Ensure you have no error messages. Then, we can install some of the rethomics packages. For instance, to install behavr. install_github(&quot;rethomics/behavr&quot;) In the same way, you could replace behavr by another package. For instance, you could install ggetho with install_github(&quot;rethomics/ggetho&quot;). 2.3 All our packages Below is a list of all the rethomics packages as well as their individual pdf documentaion, description and status. Package Doc Description Travis.CI Coverage behavr Cannonical Data Structure for Behavioural Data ggetho Visualise High-Throughput Behavioural (i.e. Ethomics) Data damr Read Drosophila Activity Monitor Data scopr Read Ethoscope Data sleepr Analyse actvity and sleep behaviour "],
["behavr.html", "Chapter 3 Generalities 3.1 Workflow 3.2 Queries 3.3 Variables and metavariables 3.4 behavr tables", " Chapter 3 Generalities This part is a conceptual section about the workflow and challenges of behavioural data analysis, and how we address them in rethomics. 3.1 Workflow todo figure 3.2 Queries When performing many experiments, with multiple condidions and replicates, it becomes challenging to keep track of each individual and to link it to its actual data. In rethomics, regardless of the tool used to generate data, loading results always involves a query. A query is a simple CSV file (basically a spreadsheet) in which each row defines one unique animal. The query contains technical information (column) such as “date”, “name of the machine used” and others. They will be used to match an animal to its data. In addition, it records arbitrary biological information describing the experiment. For instance, this is a toy query with only 3 animals: date machine_name region_id sex genotype 2015-02-20 machine_01 1 M xxx 2015-02-20 machine_03 2 F xxx 2015-02-20 machine_07 1 F zzz The region_id column define the region of interest in the behavioural arena. When performing a replicates of an experiment, it is very simple to expand a pre-existing query: date machine_name region_id sex genotype replicate 2015-02-20 machine_01 1 M xxx A 2015-02-20 machine_03 2 F xxx A 2015-02-20 machine_07 1 F zzz A 2015-03-05 machine_01 1 M xxx B 2015-03-05 machine_03 2 F xxx B 2015-03-05 machine_07 1 F zzz B It is a good habit to record as much information as possible in our queries – even if it seems redundant. For instance, if we put animals in different incubators, we can simply add an “incubator” column in our query: date machine_name region_id sex genotype replicate incubator 2015-02-20 machine_01 1 M xxx A 3 2015-02-20 machine_03 2 F xxx A 4 2015-02-20 machine_07 1 F zzz A 3 2015-03-05 machine_01 1 M xxx B 3 2015-03-05 machine_03 2 F xxx B 4 2015-03-05 machine_07 1 F zzz B 3 This way, we keep all our experimental notes, as much as possible, inside one file. Not only this will help us to “debug” if anything goes wrong in one incubator, but we will also be able to account for incubator as a covariate later on. According to the acquicisition platform (e.g. ethoscopes and DAMS), the queries may be slightly different, and we will show examples of such queries in the next parts of the tutorial. Regardless of the acquisition, though, queries are a canonical way to both record and load behavioural data. They are both computer and human friendly. In other words, if you give a query to a colaborator, she/he will be able to tell very quickly what animal underwent which treatment, where and when. 3.3 Variables and metavariables When performing behavioural experiments, many animals are individually monitored. For each of these individual, we record a set of variables (e.g. position, orientation, beam breaking,…). Each variable is recorded at successive intervals, over long durations. In addition to these variables, which change over time we also have metavariables. Metavariables contain information about each individual. This information can be defined (or recorded) before or after the experiment, but in all cases the point is that it does not change over time (e.g. treatment, genotype, lifespan). Typically, metavariables are defined as extra columns a the query file, but they can also be computed. For example, if we recorded x and y positions over time, for animals of different sex and genotype, x and y would be the variables whilst sex and genotype would be the metavariables. Regardless to what device was used to generate our data and how we loaded it, in rethomics, we will always have data and metadata linked together. 3.4 behavr tables In order to handle efficiently large amounts of data (toghter with metadata), we have designed the behavr package. A behavr table is essentially a data.table enhanced with metadata. When we load any behavioural data in rethomics, we get a behavr table as a result. Therefore, it is important to understand how to manipulate and operate on this data structure. 3.4.1 Toy data The behavr package has a set of functions to make toy data. In order to have a look at a behavr object, lets create one. First, we make a query: library(behavr) query &lt;- data.frame( experiment_id = &quot;toy_experiment&quot;, region_id = 1:10, condition = c(&quot;A&quot;, &quot;B&quot;) ) query ## experiment_id region_id condition ## 1 toy_experiment 1 A ## 2 toy_experiment 2 B ## 3 toy_experiment 3 A ## 4 toy_experiment 4 B ## 5 toy_experiment 5 A ## 6 toy_experiment 6 B ## 7 toy_experiment 7 A ## 8 toy_experiment 8 B ## 9 toy_experiment 9 A ## 10 toy_experiment 10 B Then, we use toy_dam_data() to simulate one day of DAMS-like data for these ten animals (and two conditions): dt &lt;- toy_dam_data(query, duration = days(1)) dt ## ## ==== METADATA ==== ## ## experiment_id region_id condition id ## &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;char&gt; ## 1: toy_experiment 1 A 01|toy_experiment ## 2: toy_experiment 2 B 02|toy_experiment ## 3: toy_experiment 3 A 03|toy_experiment ## 4: toy_experiment 4 B 04|toy_experiment ## 5: toy_experiment 5 A 05|toy_experiment ## 6: toy_experiment 6 B 06|toy_experiment ## 7: toy_experiment 7 A 07|toy_experiment ## 8: toy_experiment 8 B 08|toy_experiment ## 9: toy_experiment 9 A 09|toy_experiment ## 10: toy_experiment 10 B 10|toy_experiment ## ## ====== DATA ====== ## ## id t activity ## &lt;char&gt; &lt;num&gt; &lt;num&gt; ## 1: 01|toy_experiment 0 0.000000000 ## 2: 01|toy_experiment 60 0.016666667 ## 3: 01|toy_experiment 120 0.000000000 ## 4: 01|toy_experiment 180 0.008333333 ## --- ## 14406: 10|toy_experiment 86160 0.000000000 ## 14407: 10|toy_experiment 86220 0.000000000 ## 14408: 10|toy_experiment 86280 0.016666667 ## 14409: 10|toy_experiment 86340 0.008333333 ## 14410: 10|toy_experiment 86400 0.000000000 As you can see, when we print dt, our behavr table, we have two fields: METADATA and DATA. The former has only one row per animal and looks very much like query, with an extra column named id. The later is the actual data of all animals. The special column id is also known as a key. It allows to map data to metadata. In other words, there is a unique id for each individual. In this specific example, t is the time and activity is the number of beam crosses. 3.4.2 Operating on behavr tables Variables Playing with variables is just like in data.table. Read the official data.table tutorial for more functionalities. For instance, we can add a new variable, very_active that is TRUE if and only if there was at least two beam crosses in a minute: dt[, very_active := activity &gt;= 2] One can also filter data. For instance, we want to show only point before three hours: dt[t &lt; hours(3)] ## ## ==== METADATA ==== ## ## experiment_id region_id condition id ## &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;char&gt; ## 1: toy_experiment 1 A 01|toy_experiment ## 2: toy_experiment 2 B 02|toy_experiment ## 3: toy_experiment 3 A 03|toy_experiment ## 4: toy_experiment 4 B 04|toy_experiment ## 5: toy_experiment 5 A 05|toy_experiment ## 6: toy_experiment 6 B 06|toy_experiment ## 7: toy_experiment 7 A 07|toy_experiment ## 8: toy_experiment 8 B 08|toy_experiment ## 9: toy_experiment 9 A 09|toy_experiment ## 10: toy_experiment 10 B 10|toy_experiment ## ## ====== DATA ====== ## ## id t activity very_active ## &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;lgcl&gt; ## 1: 01|toy_experiment 0 0.000000000 FALSE ## 2: 01|toy_experiment 60 0.016666667 FALSE ## 3: 01|toy_experiment 120 0.000000000 FALSE ## 4: 01|toy_experiment 180 0.008333333 FALSE ## --- ## 1796: 10|toy_experiment 10500 0.000000000 FALSE ## 1797: 10|toy_experiment 10560 0.008333333 FALSE ## 1798: 10|toy_experiment 10620 0.000000000 FALSE ## 1799: 10|toy_experiment 10680 0.000000000 FALSE ## 1800: 10|toy_experiment 10740 0.000000000 FALSE Note that hours(3) just converts 3h in seconds, because time is expressed in seconds in rethomics (there is also a days() and a mins() function). Expand metavariables Sometimes, you would like to use metavariables as if they were variables. Imagine, for instance, that we want to correct activity according to the condition, say we need to multiply activity by two for condition “A”. For this purpoe, we can use the function xmv (eXpand MetaVariable): dt[, activity_corrected := ifelse(xmv(condition) == &quot;A&quot;, activity * 2, activity)] If condition were a variable, we would use ifelse(condition == &quot;A&quot;, activity * 2, activity). Since it is in metadata, we just replace condition by xmv(condition). Metadata The Metadata is itself a table. To perform operations on metadata, on can use meta=TRUE inside the [] operator. For intace, only to display the metadata: dt[meta=TRUE] ## experiment_id region_id condition id ## 1: toy_experiment 1 A 01|toy_experiment ## 2: toy_experiment 2 B 02|toy_experiment ## 3: toy_experiment 3 A 03|toy_experiment ## 4: toy_experiment 4 B 04|toy_experiment ## 5: toy_experiment 5 A 05|toy_experiment ## 6: toy_experiment 6 B 06|toy_experiment ## 7: toy_experiment 7 A 07|toy_experiment ## 8: toy_experiment 8 B 08|toy_experiment ## 9: toy_experiment 9 A 09|toy_experiment ## 10: toy_experiment 10 B 10|toy_experiment We can use the same principle to add new metavariable: dt[, my_new_column := interaction(region_id, condition), meta=TRUE] dt[meta=TRUE] ## experiment_id region_id condition id my_new_column ## 1: toy_experiment 1 A 01|toy_experiment 1.A ## 2: toy_experiment 2 B 02|toy_experiment 2.B ## 3: toy_experiment 3 A 03|toy_experiment 3.A ## 4: toy_experiment 4 B 04|toy_experiment 4.B ## 5: toy_experiment 5 A 05|toy_experiment 5.A ## 6: toy_experiment 6 B 06|toy_experiment 6.B ## 7: toy_experiment 7 A 07|toy_experiment 7.A ## 8: toy_experiment 8 B 08|toy_experiment 8.B ## 9: toy_experiment 9 A 09|toy_experiment 9.A ## 10: toy_experiment 10 B 10|toy_experiment 10.B Summarise data At some point, we will want to compute one or several summary variables for each animal and, for instance, model these versus metavariable. For instance, we could compute the sum of all activity for each animal. Since each animal is identified by its id, we use by=id for this: summary_dt &lt;- dt[, .(sum_activity = sum(activity)), by=id] summary_dt ## ## ==== METADATA ==== ## ## experiment_id region_id condition id my_new_column ## &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;char&gt; &lt;fctr&gt; ## 1: toy_experiment 1 A 01|toy_experiment 1.A ## 2: toy_experiment 2 B 02|toy_experiment 2.B ## 3: toy_experiment 3 A 03|toy_experiment 3.A ## 4: toy_experiment 4 B 04|toy_experiment 4.B ## 5: toy_experiment 5 A 05|toy_experiment 5.A ## 6: toy_experiment 6 B 06|toy_experiment 6.B ## 7: toy_experiment 7 A 07|toy_experiment 7.A ## 8: toy_experiment 8 B 08|toy_experiment 8.B ## 9: toy_experiment 9 A 09|toy_experiment 9.A ## 10: toy_experiment 10 B 10|toy_experiment 10.B ## ## ====== DATA ====== ## ## id sum_activity ## &lt;char&gt; &lt;num&gt; ## 1: 01|toy_experiment 3.125000 ## 2: 02|toy_experiment 5.683333 ## 3: 03|toy_experiment 6.141667 ## 4: 04|toy_experiment 2.700000 ## 5: 05|toy_experiment 5.391667 ## 6: 06|toy_experiment 6.175000 ## 7: 07|toy_experiment 2.058333 ## 8: 08|toy_experiment 5.691667 ## 9: 09|toy_experiment 2.191667 ## 10: 10|toy_experiment 3.241667 Now, the data is only one point per animal, with id, and our new variable. We aggreated the data, so it is quite managable to put the summary data and the metadata in the same table. For that, we use rejoin: final_dt &lt;- rejoin(summary_dt) final_dt ## experiment_id region_id condition id my_new_column ## 1: toy_experiment 1 A 01|toy_experiment 1.A ## 2: toy_experiment 2 B 02|toy_experiment 2.B ## 3: toy_experiment 3 A 03|toy_experiment 3.A ## 4: toy_experiment 4 B 04|toy_experiment 4.B ## 5: toy_experiment 5 A 05|toy_experiment 5.A ## 6: toy_experiment 6 B 06|toy_experiment 6.B ## 7: toy_experiment 7 A 07|toy_experiment 7.A ## 8: toy_experiment 8 B 08|toy_experiment 8.B ## 9: toy_experiment 9 A 09|toy_experiment 9.A ## 10: toy_experiment 10 B 10|toy_experiment 10.B ## sum_activity ## 1: 3.125000 ## 2: 5.683333 ## 3: 6.141667 ## 4: 2.700000 ## 5: 5.391667 ## 6: 6.175000 ## 7: 2.058333 ## 8: 5.691667 ## 9: 2.191667 ## 10: 3.241667 This table is now perfectly suited for further statistical analysis and visualisation! Stitching TODO "]
]
