[
["index.html", "Rethomics, a framework for high-throughput behaviour analysis in R Chapter 1 Introduction", " Rethomics, a framework for high-throughput behaviour analysis in R Quentin Geissmann 2017-09-06 Chapter 1 Introduction If we share a common data structure, we can use a commmon set of tools In the last few years, there has been growing interests in ethomics – that is, the analysis of large behavioural data sets. Many software and hardware solutions have been proposed to record different behavioural variables on several model organisms. Although are many similarities in the analysis and visualisation that are independent of the acquisition tool, each method tends to provide its own output format and, in practice, its own analysis software. This results in a lot of replicated work and prohibits interation between methods of analysis. Rethomics attempts to unify analysis of behaviour by providing: * behavr tables – a flexible and universal structure to handle very large behavioural data sets * damr, scopr, … – packages to load data from DAMS, ethoscopes and others into behavr tables * ggetho – a package, based on ggplot2, to produce high quality visualisation of behavioural data * sleepr, rhythmr, … – packages to analyse behavioural data (sleep analysis, circadian rhythm, …). "],
["these-solutions-mostly-generate-their-own-data-format.html", "Chapter 2 These solutions mostly generate their own data format", " Chapter 2 These solutions mostly generate their own data format "],
["although-analysis-of-the-data.html", "Chapter 3 Although, analysis of the data", " Chapter 3 Although, analysis of the data This document is a tutorial intended for experimenters and data analysts. It provides a suite of both theoretical explanations and very concrete examples. Background In the last few years, the ability to acquire large amount of behavioural data from multiple individual experimental animals has dramatically increased. However, there are still very few tools that allow biologists to read, store, visualise and process data in a modular and consistent pipeline. The rethomics framework is a collection of R packages that work together in order to provide a programmatic and efficient environment to analyse behavioural data. Since R is a state of the art software for scientific data visualisation and analysis, rethomics integrates into a rich ecosystem of high-standard tools. "],
["intro.html", "Chapter 4 First Steps 4.1 Getting R 4.2 Installing rethomics packages 4.3 All rethomics packages", " Chapter 4 First Steps 4.1 Getting R If you have never used or heard of R before, I suggest you start by reading about R and installing RStudio. Only once you have done can we continue. 4.2 Installing rethomics packages As of today (“2017-09-06”), rethomics packages are not on CRAN, the official R package archive yet. Therefore, we will install the developmental version. For that, we have to install (once for all) use devtools and load it: install.packages(&quot;devtools&quot;) library(devtools) Ensure you have no error messages. Then, we can install some of the rethomics packages. For instance, to install behavr. install_github(&quot;rethomics/behavr&quot;) In the same way, you could replace behavr by another package. For instance, you could install ggetho with install_github(&quot;rethomics/ggetho&quot;). 4.3 All rethomics packages Below is a list of all the rethomics packages as well as their individual pdf documentation, description and status. Package Doc Description Travis.CI Coverage behavr Canonical Data Structure for Behavioural Data ggetho Visualise High-Throughput Behavioural (i.e. Ethomics) Data damr Read Drosophila Activity Monitor Data scopr Read Ethoscope Data sleepr Analyse actvity and sleep behaviour rhythmr Unavailable "],
["behavr.html", "Chapter 5 Generalities 5.1 Workflow 5.2 Queries 5.3 Variables and metavariables 5.4 behavr tables", " Chapter 5 Generalities This part is a conceptual section about the workflow and challenges of behavioural data analysis, and how we address them in rethomics. 5.1 Workflow todo figure 5.2 Queries When performing many experiments, with multiple condidions and replicates, it becomes challenging to keep track of each individual and to link it to its actual data. In rethomics, regardless of the tool used to generate data, loading results always involves a query. A query is a simple CSV file (basically a spreadsheet) in which each row defines one unique animal. The query contains technical information (column) such as “date”, “name of the machine used” and others. They will be used to match an animal to its data. In addition, it records arbitrary biological information describing the experiment. For instance, this is a toy query with only 3 animals: date machine_name region_id sex genotype 2015-02-20 machine_01 1 M xxx 2015-02-20 machine_03 2 F xxx 2015-02-20 machine_07 1 F zzz The region_id column define the region of interest in the behavioural arena. When performing a replicates of an experiment, it is very simple to expand a pre-existing query: date machine_name region_id sex genotype replicate 2015-02-20 machine_01 1 M xxx A 2015-02-20 machine_03 2 F xxx A 2015-02-20 machine_07 1 F zzz A 2015-03-05 machine_01 1 M xxx B 2015-03-05 machine_03 2 F xxx B 2015-03-05 machine_07 1 F zzz B It is a good habit to record as much information as possible in our queries – even if it seems redundant. For instance, if we put animals in different incubators, we can simply add an “incubator” column in our query: date machine_name region_id sex genotype replicate incubator 2015-02-20 machine_01 1 M xxx A 3 2015-02-20 machine_03 2 F xxx A 4 2015-02-20 machine_07 1 F zzz A 3 2015-03-05 machine_01 1 M xxx B 3 2015-03-05 machine_03 2 F xxx B 4 2015-03-05 machine_07 1 F zzz B 3 This way, we keep all our experimental notes, as much as possible, inside one file. Not only this will help us to “debug” if anything goes wrong in one incubator, but we will also be able to account for incubator as a covariate later on. According to the acquicisition platform (e.g. ethoscopes and DAMS), the queries may be slightly different, and we will show examples of such queries in the next parts of the tutorial. Regardless of the acquisition, though, queries are a canonical way to both record and load behavioural data. They are both computer and human friendly. In other words, if you give a query to a colaborator, she/he will be able to tell very quickly what animal underwent which treatment, where and when. 5.3 Variables and metavariables When performing behavioural experiments, many animals are individually monitored. For each of these individual, we record a set of variables (e.g. position, orientation, beam breaking,…). Each variable is recorded at successive intervals, over long durations. In addition to these variables, which change over time we also have metavariables. Metavariables contain information about each individual. This information can be defined (or recorded) before or after the experiment, but in all cases the point is that it does not change over time (e.g. treatment, genotype, lifespan). Typically, metavariables are defined as extra columns a the query file, but they can also be computed. For example, if we recorded x and y positions over time, for animals of different sex and genotype, x and y would be the variables whilst sex and genotype would be the metavariables. Regardless to what device was used to generate our data and how we loaded it, in rethomics, we will always have data and metadata linked together. 5.4 behavr tables In order to handle efficiently large amounts of data (toghter with metadata), we have designed the behavr package. A behavr table is essentially a data.table enhanced with metadata. When we load any behavioural data in rethomics, we get a behavr table as a result. Therefore, it is important to understand how to manipulate and operate on this data structure. 5.4.1 Toy data The behavr package has a set of functions to make toy data. In order to have a look at a behavr object, lets create one. First, we make a query: library(behavr) query &lt;- data.frame( experiment_id = &quot;toy_experiment&quot;, region_id = 1:10, condition = c(&quot;A&quot;, &quot;B&quot;) ) query ## experiment_id region_id condition ## 1 toy_experiment 1 A ## 2 toy_experiment 2 B ## 3 toy_experiment 3 A ## 4 toy_experiment 4 B ## 5 toy_experiment 5 A ## 6 toy_experiment 6 B ## 7 toy_experiment 7 A ## 8 toy_experiment 8 B ## 9 toy_experiment 9 A ## 10 toy_experiment 10 B Then, we use toy_dam_data() to simulate one day of DAMS-like data for these ten animals (and two conditions): dt &lt;- toy_dam_data(query, duration = days(1)) dt ## ## ==== METADATA ==== ## ## id experiment_id region_id condition ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B ## ## ====== DATA ====== ## ## id t activity ## &lt;fctr&gt; &lt;num&gt; &lt;int&gt; ## 1: 01|toy_experiment 0 0 ## 2: 01|toy_experiment 60 2 ## 3: 01|toy_experiment 120 0 ## 4: 01|toy_experiment 180 1 ## --- ## 14406: 10|toy_experiment 86160 0 ## 14407: 10|toy_experiment 86220 0 ## 14408: 10|toy_experiment 86280 2 ## 14409: 10|toy_experiment 86340 1 ## 14410: 10|toy_experiment 86400 0 As you can see, when we print dt, our behavr table, we have two fields: METADATA and DATA. The former has only one row per animal and looks very much like query, with an extra column named id. The later is the actual data of all animals. The special column id is also known as a key. It allows to map data to metadata. In other words, there is a unique id for each individual. In this specific example, t is the time and activity is the number of beam crosses. A quick way to retreive general information about a behavr table is to use summary: summary(dt) ## behavr table with: ## 10 individuals ## 3 metavariables ## 2 variables ## 1.441e+04 measurements ## 1 key (id) This tells us immediately how many variables and metavariables we have. It also tells us when are the first and last recording for each animal. 5.4.2 Operating on behavr tables Variables Playing with variables is just like in data.table. Read the official data.table tutorial for more functionalities. For instance, we can add a new variable, very_active that is TRUE if and only if there was at least two beam crosses in a minute: dt[, very_active := activity &gt;= 2] One can also filter data. For instance, we want to show only point before three hours: dt[t &lt; hours(3)] ## ## ==== METADATA ==== ## ## id experiment_id region_id condition ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B ## ## ====== DATA ====== ## ## id t activity very_active ## &lt;fctr&gt; &lt;num&gt; &lt;int&gt; &lt;lgcl&gt; ## 1: 01|toy_experiment 0 0 FALSE ## 2: 01|toy_experiment 60 2 TRUE ## 3: 01|toy_experiment 120 0 FALSE ## 4: 01|toy_experiment 180 1 FALSE ## --- ## 1796: 10|toy_experiment 10500 0 FALSE ## 1797: 10|toy_experiment 10560 1 FALSE ## 1798: 10|toy_experiment 10620 0 FALSE ## 1799: 10|toy_experiment 10680 0 FALSE ## 1800: 10|toy_experiment 10740 0 FALSE Note that hours(3) just converts 3h in seconds, because time is expressed in seconds in rethomics (there is also a days() and a mins() function). Expand metavariables Sometimes, you would like to use metavariables as if they were variables. Imagine, for instance, that we want to correct activity according to the condition, say we need to multiply activity by two for condition “A”. For this purpoe, we can use the function xmv (eXpand MetaVariable): dt[, activity_corrected := ifelse(xmv(condition) == &quot;A&quot;, activity * 2, activity)] If condition were a variable, we would use ifelse(condition == &quot;A&quot;, activity * 2, activity). Since it is in metadata, we just replace condition by xmv(condition). Metadata The Metadata is itself a table. To perform operations on metadata, on can use meta=TRUE inside the [] operator. For intace, only to display the metadata: dt[meta=TRUE] ## id experiment_id region_id condition ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B We can use the same principle to add new metavariable: dt[, my_new_column := interaction(region_id, condition), meta=TRUE] dt[meta=TRUE] ## id experiment_id region_id condition my_new_column ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B Summarise data At some point, we will want to compute one or several summary variables for each animal and, for instance, model these versus metavariable. For instance, we could compute the sum of all activity for each animal. Since each animal is identified by its id, we use by=id for this: summary_dt &lt;- dt[, .(sum_activity = sum(activity)), by=id] summary_dt ## ## ==== METADATA ==== ## ## id experiment_id region_id condition my_new_column ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B ## ## ====== DATA ====== ## ## id sum_activity ## &lt;fctr&gt; &lt;int&gt; ## 1: 01|toy_experiment 375 ## 2: 02|toy_experiment 682 ## 3: 03|toy_experiment 737 ## 4: 04|toy_experiment 324 ## 5: 05|toy_experiment 647 ## 6: 06|toy_experiment 741 ## 7: 07|toy_experiment 247 ## 8: 08|toy_experiment 683 ## 9: 09|toy_experiment 263 ## 10: 10|toy_experiment 389 Now, the data is only one point per animal, with id, and our new variable. We aggreated the data, so it is quite managable to put the summary data and the metadata in the same table. For that, we use rejoin: final_dt &lt;- rejoin(summary_dt) final_dt ## id experiment_id region_id condition my_new_column ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B ## sum_activity ## 1: 375 ## 2: 682 ## 3: 737 ## 4: 324 ## 5: 647 ## 6: 741 ## 7: 247 ## 8: 683 ## 9: 263 ## 10: 389 This table is now perfectly suited for further statistical analysis and visualisation! Stitching TODO "]
]
