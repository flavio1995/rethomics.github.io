[
["index.html", "Rethomics, a framework for high-throughput behaviour analysis in R Introduction", " Rethomics, a framework for high-throughput behaviour analysis in R Quentin Geissmann 2017-10-25 Introduction Only if we share a common data structure can we use a common set of tools The rethomics framework unify behaviour analysis over multiple platforms In the last few years, there has been growing interests in ethomics – that is, the analysis of large behavioural data sets. Many software and hardware solutions have been proposed to record different behavioural variables on several model organisms. Although subsequent analysis and visualisation share many similarities, each method tends to provide its own output format and, in practice, its own restricted analysis software. This results in a lot of replicated work but also limits extension and collaboration. Rethomics attempts to unify analysis of behaviour by providing several packages: behavr tables – a flexible and universal structure to handle very large behavioural data sets damr, scopr, … – to load data from DAMS, ethoscopes and others into behavr tables ggetho – based on ggplot2, to produce high-quality representations of behavioural data sleepr, zeitgebr, … – to analyse behavioural data (sleep analysis, circadian rhythm, …) This document is a tutorial intended for experimenters as well as data analysts. It provides a suite of both conceptual explanations and very concrete examples. "],
["intro.html", "First Steps Getting R Installing rethomics packages List of rethomics packages", " First Steps Getting R If you have never used or heard of R before, I suggest you start by reading about data science in R and installing RStudio. Only once you have done can we continue. Installing rethomics packages As of today (2017-10-25), rethomics packages are not on CRAN, the official R package archive yet. Therefore, we will install the developmental version. As a prerequisite, we need to install (once for all) devtools and load it: install.packages(&quot;devtools&quot;) library(devtools) Ensure you have no error messages. Then, we can install some of the rethomics packages. For instance, lets install behavr. install_github(&quot;rethomics/behavr&quot;) In the same way, you could replace behavr by another package. For instance, you could install ggetho with install_github(&quot;rethomics/ggetho&quot;). List of rethomics packages Below is a list of all the rethomics packages as well as their individual PDF documentation, description and build status. Package Doc Description Travis.CI Coverage behavr Canonical Data Structure for Behavioural Data ggetho Visualise High-Throughput Behavioural (i.e. Ethomics) Data damr Read Drosophila Activity Monitor Data scopr Read Ethoscope Data sleepr Analyse Activity and Sleep Behaviour zeitgebr Analyse and Visualise Circadian Behaviours "],
["workflow.html", "The rethomics workflow", " The rethomics workflow From hypothesis to results The rethomics workflow In rethomics, we envisage behavioural experiments as a workflow: Design – you plan your experiment (I can’t really help you with that, but I trust you!). Record/track – you use your acquisition platfrom to record behavioural variables over time. They define the format of the results. Write individual information – you make a spreadsheet (CSV file) that details the experimental conditions for each individual. We call this a metadata file. It is a crucial concept in rethomics, so we will dedicate it the next section. You can often write your metadata as you plan your experiment, but sometimes, you want to enrich it with variables that you can only record after your experiment (e.g. lifespan). Link and Load data – First, we enrich your metadata by “linking” it to the result. This allows you to load all the matching data into a singlebehavr table (see section on behavr tables). Tranform &amp; analyse &amp; visualise – you take advantage of rethomics and R analysis and visualisation tools. "],
["metadata.html", "Working with metadata files What are metadata? Make them exhaustive Put replicates together Linking metadata Take home message", " Working with metadata files Using and understanding metadata files makes your analyses more transparent and tracktable Schematic of a metadata file What are metadata? When performing many experiments, with multiple condidions and replicates, it becomes challenging to keep track of each individual and to link it to its actual data. In rethomics, regardless of the tool used to generate data, loading results always involves a metadata file. It is, in fact, a simple CSV file (basically a spreadsheet) in which each row defines one unique individual. As shown in the figure above, metadata is classified in two types of columns: Mandatory techincal columns – for instance date, machine_name and others (depending on the acquisition platform). They will be used to match an animal to its data. Optional experimental columns – in this example, condition and sex. You can use as all the columns you want to characterise your experiments. Make them exhaustive It is a good habit to record as much information as possible in our metadata – even if it seems redundant. For instance, if we put animals in different incubators, we can simply add an incubator column. This way, we keep all our experimental notes, as much as possible, inside one file. Not only this will help us to “debug” if anything goes wrong in one incubator, but we will also be able to account for incubator as a covariate later on. From a computational perspective, these columns are virtually free. Put replicates together A common mistake for users is to perform several replicates of the same experiment and to make a new metadata file each time. Instead, I strongly recommand you to put all replicates in the same file. If it helps, you can add a replicate column so you can keep track of which replicate each animal comes from. The whole point of high-througput analysis is that you can load all the data from all replicates and compare it (and maybe merge it). The bottom line is that, if you start form a single metadata file, your work will be more tracktable, and you can always decide to analyse only one replicate at a time. Linking metadata Linking adds technical columns Once your metadata is ready, it can be used to create a query to import the matching data. Regardless of which acquisition tool you used, the first step when importing data in R will be “metadata linking”. This step will automatically complete the metadata file in a way that can be used for R to retrieve the right amount of data from experiment files. We call it linking, since it links the manually introduced metadata with the right experiment data file, something that is tedious to do manually. In short, linking means at least: Adding an id column to the metadata. This will be a unique identifier for each indididual (it generally contains datetime, machine name an region id). This will diferenciate animals with the same conditions in the metadata. Adding a column that tracks “how to find the data for each individual”. Take home message In conclusion, metadatafiles are a canonical way to both define experimental condition and load behavioural data. They are both computer and human friendly. In other words, if you give a query to a colaborator, she/he will be able to tell very quickly what animal underwent which treatment, where and when. "],
["behavr.html", "behavr tables Variables and metavariables Operating on behavr tables Playing with toy data Generalities", " behavr tables A single data structure to store data and metadata a behavr table Variables and metavariables As we have seen in the previous section, metadata are crucial for proper statistical analysis of behavioural data. The point of an experiment, is however to acquire data. That is, a long time series of recorded variables such as position, orientation and number of beam crosses, for each individual. Variables are different form metavariables in so far as the latter are made of only one value per animal. It is easier (and less error prone) to always keep the data and metadata together. In rethomics, in order to handle large amounts of data (together with metadata), we have designed the behavr package. behavr tables are based on the very powerful package data.table, but enhanced with metadata. For most purposes, you can use a behavr table just like a data.table. Therefore, have a look at the introduction to data.table further detail! When we load any behavioural data in rethomics, we get a behavr table as a result. In this section, we will discuss the usual operations that you can perform on behavr tables. Operating on behavr tables Now that we have all our data at the same place, we want to be able to manipulate it. In the next part of this tutorial, we will create some toy data and learn how to manipulate it. This table is a short overview: Section Operation Expression Example Generalities Summarise behavr table summary(DT) How many individuals, variables, metavariables, etc? – summary(dt) Pure data Create/alter a variable DT[, new_column := some_value] When are aninimals ‘very active’? – dt[, very_active := activity &gt;= 2] Remove a variable DT[, column_to_delete := NULL] Lets remove a variable we don’t need? – dt[, very_active := NULL] Select data rows DT[criteria] Exclude data before the first hour – small_dt &lt;- dt[t &gt; hours(1)] Pure metadata Access metadata table DT[meta = TRUE] Show metadata as table – dt[meta = TRUE] Create/alter metavariable DT[, new_meta := some_value, meta=TRUE] Define a new factor that is a comibiation of ‘sex x condition’ – dt[, treatment := paste(sex, condition, sep='|'), meta=T] Meta &amp; data Use metavariable as variable xmv(metavariable) Add 10s to all time, only for animals in condition 'A' – dt[, t := ifelse(xmv(condition) == 'A', t + 10, t)] Remove individuals according to metavariable DT[criteria] Remove all males (from data, and metadata) – dt_males &lt;- dt[xmv(sex) == 'females'] Summarise Compute indidisual statistics DT[, .( statistics = some_math()), by='id'] Compute the average activity, per animal – stat_dt &lt;- dt[, .(mean_acti = mean(active)), by='id'] Rejoin metadata to data rejoin(DT) Merge metadata and summary statistics – stat_dt &lt;- rejoin(stat_dt) Advanced Stitch experiments stitch_on(DT, metavariable) TODO – TODO Playing with toy data The behavr package has a set of functions to make toy data. In order to have a look at a behavr object, lets create one. First, we make the metadata: library(behavr) ## Loading required package: data.table metadata &lt;- data.table( id = paste(&quot;toy_experiment&quot;, 1:10, sep = &quot;|&quot;), sex = rep(c(&quot;male&quot;, &quot;female&quot;), each = 5), condition = c(&quot;A&quot;, &quot;B&quot;) ) metadata ## id sex condition ## 1: toy_experiment|1 male A ## 2: toy_experiment|2 male B ## 3: toy_experiment|3 male A ## 4: toy_experiment|4 male B ## 5: toy_experiment|5 male A ## 6: toy_experiment|6 female B ## 7: toy_experiment|7 female A ## 8: toy_experiment|8 female B ## 9: toy_experiment|9 female A ## 10: toy_experiment|10 female B Then, we use toy_dam_data() to simulate (instead of linking/loading) one day of DAMS-like data for these ten animals (and two conditions): dt &lt;- toy_dam_data(metadata, duration = days(1)) dt ## ## ==== METADATA ==== ## ## id sex condition ## &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|1 male A ## 2: toy_experiment|10 female B ## 3: toy_experiment|2 male B ## 4: toy_experiment|3 male A ## 5: toy_experiment|4 male B ## 6: toy_experiment|5 male A ## 7: toy_experiment|6 female B ## 8: toy_experiment|7 female A ## 9: toy_experiment|8 female B ## 10: toy_experiment|9 female A ## ## ====== DATA ====== ## ## id t activity ## &lt;char&gt; &lt;num&gt; &lt;int&gt; ## 1: toy_experiment|1 0 0 ## 2: toy_experiment|1 60 2 ## 3: toy_experiment|1 120 0 ## 4: toy_experiment|1 180 1 ## --- ## 14406: toy_experiment|9 86160 0 ## 14407: toy_experiment|9 86220 0 ## 14408: toy_experiment|9 86280 2 ## 14409: toy_experiment|9 86340 1 ## 14410: toy_experiment|9 86400 0 As you can see, when we print dt, our behavr table, we have two fields: METADATA and DATA. The former is actually just the metadata we created whilst the latter stores the data (i.e. the variables) for all animals. The special column id is also known as a key, and is shared between both data and metadata. It inernally allows us to map them to one another. In other words, it is a unique id for each individual. In this specific example, the variables t and activity are the time and the number of beam crosses, respectively. Generalities A quick way to retreive general information about a behavr table is to use summary: summary(dt) ## behavr table with: ## 10 individuals ## 2 metavariables ## 2 variables ## 1.441e+04 measurements ## 1 key (id) This tells us immediately how many variables, metavariables and data points, we have. One can also print a detailed summary (i.e. one per animal): summary(dt, detailed = TRUE) ## ## Summary of each individual (one per row): ## id sex condition data_points time_range ## 1: toy_experiment|1 male A 1441 [0 -&gt; 86400 (86400)] ## 2: toy_experiment|10 female B 1441 [0 -&gt; 86400 (86400)] ## 3: toy_experiment|2 male B 1441 [0 -&gt; 86400 (86400)] ## 4: toy_experiment|3 male A 1441 [0 -&gt; 86400 (86400)] ## 5: toy_experiment|4 male B 1441 [0 -&gt; 86400 (86400)] ## 6: toy_experiment|5 male A 1441 [0 -&gt; 86400 (86400)] ## 7: toy_experiment|6 female B 1441 [0 -&gt; 86400 (86400)] ## 8: toy_experiment|7 female A 1441 [0 -&gt; 86400 (86400)] ## 9: toy_experiment|8 female B 1441 [0 -&gt; 86400 (86400)] ## 10: toy_experiment|9 female A 1441 [0 -&gt; 86400 (86400)] Data Playing with variables is just like in data.table. Read the official data.table tutorial for more functionalities. For instance, we can add a new variable, very_active, that is TRUE if and only if there was at least two beam crosses in a minute, for a given individual: dt[, very_active := activity &gt;= 2] If we decide we don’t need this variable anymore, we can remove it: dt[, very_active := NULL] Sometimes, we would like to filter the data. That is, we select rows according to one or several criteria. Often we would lile to exclude thew very start of the experiment. For example, we can keep data after one hour: dt &lt;- dt[ t &gt; hours(1)] Note that that using dt &lt;- mean we make a new table that overwrite the old one (since it has the same name). Metadata In order to access the metadata, we can add meta = TRUE inside the []: dt[meta = TRUE] ## id sex condition ## 1: toy_experiment|1 male A ## 2: toy_experiment|10 female B ## 3: toy_experiment|2 male B ## 4: toy_experiment|3 male A ## 5: toy_experiment|4 male B ## 6: toy_experiment|5 male A ## 7: toy_experiment|6 female B ## 8: toy_experiment|7 female A ## 9: toy_experiment|8 female B ## 10: toy_experiment|9 female A This way, we can also create new metavariables. For instance, say you want to collapse sex and condition which both have two levels into one treatment, with four levels: dt[, treatment := paste(sex, condition, sep=&#39;|&#39;), meta=T] # just to show the result: dt[meta = TRUE] ## id sex condition treatment ## 1: toy_experiment|1 male A male|A ## 2: toy_experiment|10 female B female|B ## 3: toy_experiment|2 male B male|B ## 4: toy_experiment|3 male A male|A ## 5: toy_experiment|4 male B male|B ## 6: toy_experiment|5 male A male|A ## 7: toy_experiment|6 female B female|B ## 8: toy_experiment|7 female A female|A ## 9: toy_experiment|8 female B female|B ## 10: toy_experiment|9 female A female|A Data &amp; Metadata The strength of behavr tables is their ability to seamlessly use metavariables as though they were variables. For the sake of the example, lets say you would like to alter the variable t (time) so that we add ten seconds, only to individuals that have condition 'A'. dt[, t := ifelse(xmv(condition) == &#39;A&#39;, t + 10, t)] The key here is the use of xmv (eXpand MetaVariable), which maps condition back in the data. We can also use this mechanism to remove individual according to the value of a metavariable. For instance, lets get rid of the males! dt &lt;- dt[xmv(sex) == &#39;female&#39;] summary(dt) ## behavr table with: ## 5 individuals ## 3 metavariables ## 2 variables ## 6.9e+03 measurements ## 1 key (id) When individuals are removed, metadata is automatically updated. In effect, we removed males from both data and metadata. Summerise data Thanks to data table by operations, it is simple and efficient to compute statistics per individual. For instance, we may want to compute the average activity for each animal: stat_dt &lt;- dt[, .(mean_acti = mean(activity)), by=&#39;id&#39;] stat_dt ## ## ==== METADATA ==== ## ## id sex condition treatment ## &lt;char&gt; &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|10 female B female|B ## 2: toy_experiment|6 female B female|B ## 3: toy_experiment|7 female A female|A ## 4: toy_experiment|8 female B female|B ## 5: toy_experiment|9 female A female|A ## ## ====== DATA ====== ## ## id mean_acti ## &lt;char&gt; &lt;num&gt; ## 1: toy_experiment|10 0.4420290 ## 2: toy_experiment|6 0.1615942 ## 3: toy_experiment|7 0.4434783 ## 4: toy_experiment|8 0.1731884 ## 5: toy_experiment|9 0.2550725 You can actually compute many variables in one go this way: stat_dt &lt;- dt[, .(mean_acti = mean(activity), max_acti = max(activity) ), by=&#39;id&#39;] stat_dt ## ## ==== METADATA ==== ## ## id sex condition treatment ## &lt;char&gt; &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|10 female B female|B ## 2: toy_experiment|6 female B female|B ## 3: toy_experiment|7 female A female|A ## 4: toy_experiment|8 female B female|B ## 5: toy_experiment|9 female A female|A ## ## ====== DATA ====== ## ## id mean_acti max_acti ## &lt;char&gt; &lt;num&gt; &lt;int&gt; ## 1: toy_experiment|10 0.4420290 3 ## 2: toy_experiment|6 0.1615942 2 ## 3: toy_experiment|7 0.4434783 3 ## 4: toy_experiment|8 0.1731884 2 ## 5: toy_experiment|9 0.2550725 2 Now, in order to perform statistics, we would lke to merge our summaries to the metadata. That is we want to rejoin them: final_dt &lt;- rejoin(stat_dt) final_dt ## id sex condition treatment mean_acti max_acti ## 1: toy_experiment|10 female B female|B 0.4420290 3 ## 2: toy_experiment|6 female B female|B 0.1615942 2 ## 3: toy_experiment|7 female A female|A 0.4434783 3 ## 4: toy_experiment|8 female B female|B 0.1731884 2 ## 5: toy_experiment|9 female A female|A 0.2550725 2 This table is exactly what you need for statistcis and vidualisation in R! Stitching TODO "]
]
