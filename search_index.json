[
["index.html", "Rethomics, a framework for high-throughput behaviour analysis in R Introduction", " Rethomics, a framework for high-throughput behaviour analysis in R Quentin Geissmann 2017-11-24 Introduction Only if we share a common data structure can we use a common set of tools The rethomics framework unify behaviour analysis over multiple platforms In the last few years, there has been growing interests in ethomics – that is, the analysis of large behavioural data sets. Many software and hardware solutions have been proposed to record different behavioural variables on several model organisms. Although subsequent analysis and visualisation share many similarities, each method tends to provide its own output format and, in practice, its own restricted analysis software. This results in a lot of replicated work but also limits extension and collaboration. Rethomics attempts to unify analysis of behaviour by providing several packages: behavr tables – a flexible and universal structure to handle very large behavioural data sets damr, scopr, … – to load data from DAMS, ethoscopes and others into behavr tables ggetho – based on ggplot2, to produce high-quality representations of behavioural data sleepr, zeitgebr, … – to analyse behavioural data (sleep analysis, circadian rhythm, …) This document is a tutorial intended for experimenters as well as data analysts. It provides a suite of both conceptual explanations and very concrete examples. "],
["intro.html", "First Steps Getting R Installing rethomics packages List of rethomics packages", " First Steps Getting R If you have never used or heard of R before, I suggest you start by reading about data science in R and installing RStudio. Only once you have done can we continue. Installing rethomics packages As of today (2017-11-24), rethomics packages are not on CRAN, the official R package archive yet. Therefore, we will install the developmental version. As a prerequisite, we need to install (once for all) devtools and load it: install.packages(&quot;devtools&quot;) library(devtools) Ensure you have no error messages. Then, we can install some of the rethomics packages. For instance, lets install behavr. install_github(&quot;rethomics/behavr&quot;) In the same way, you could replace behavr by another package. For instance, you could install ggetho with install_github(&quot;rethomics/ggetho&quot;). List of rethomics packages Below is a list of all the rethomics packages as well as their individual PDF documentation, description and build status. Package Doc Description Travis.CI Coverage behavr Canonical Data Structure for Behavioural Data ggetho Visualise High-Throughput Behavioural (i.e. Ethomics) Data damr Read Drosophila Activity Monitor Data scopr Read Ethoscope Data sleepr Analyse Activity and Sleep Behaviour zeitgebr Analyse and Visualise Circadian Behaviours "],
["workflow.html", "The rethomics workflow", " The rethomics workflow From hypothesis to results The rethomics workflow In rethomics, we envisage behavioural experiments as a workflow: Design – you plan your experiment (I can’t really help you with that, but I trust you!). Record/track – you use your acquisition platfrom to record behavioural variables over time. They define the format of the results. Write individual information – you make a spreadsheet (CSV file) that details the experimental conditions for each individual. We call this a metadata file. It is a crucial concept in rethomics, so we will dedicate it the next section. You can often write your metadata as you plan your experiment, but sometimes, you want to enrich it with variables that you can only record after your experiment (e.g. lifespan). Link and Load data – First, we enrich your metadata by “linking” it to the result. This allows you to load all the matching data into a singlebehavr table (see section on behavr tables). Tranform &amp; analyse &amp; visualise – you take advantage of rethomics and R analysis and visualisation tools. "],
["metadata.html", "Working with metadata files What are metadata? Make them exhaustive Put replicates together Linking metadata Take home message", " Working with metadata files Using and understanding metadata files makes your analyses more transparent and tracktable Schematic of a metadata file What are metadata? When performing many experiments, with multiple condidions and replicates, it becomes challenging to keep track of each individual and to link it to its actual data. In rethomics, regardless of the tool used to generate data, loading results always involves a metadata file. It is, in fact, a simple CSV file (basically a spreadsheet) in which each row defines one unique individual. As shown in the figure above, metadata is classified in two types of columns: Mandatory techincal columns – for instance date, machine_name and others (depending on the acquisition platform). They will be used to match an animal to its data. Optional experimental columns – in this example, condition and sex. You can use as all the columns you want to characterise your experiments. Make them exhaustive It is a good habit to record as much information as possible in our metadata – even if it seems redundant. For instance, if we put animals in different incubators, we can simply add an incubator column. This way, we keep all our experimental notes, as much as possible, inside one file. Not only this will help us to “debug” if anything goes wrong in one incubator, but we will also be able to account for incubator as a covariate later on. From a computational perspective, these columns are virtually free. Put replicates together A common mistake for users is to perform several replicates of the same experiment and to make a new metadata file each time. Instead, I strongly recommand you to put all replicates in the same file. If it helps, you can add a replicate column so you can keep track of which replicate each animal comes from. The whole point of high-througput analysis is that you can load all the data from all replicates and compare it (and maybe merge it). The bottom line is that, if you start form a single metadata file, your work will be more tracktable, and you can always decide to analyse only one replicate at a time. Linking metadata Linking adds technical columns Once your metadata is ready, it can be used to create a query to import the matching data. Regardless of which acquisition tool you used, the first step when importing data in R will be “metadata linking”. This step will automatically complete the metadata file in a way that can be used for R to retrieve the right amount of data from experiment files. We call it linking, since it links the manually introduced metadata with the right experiment data file, something that is tedious to do manually. In short, linking means at least: Adding an id column to the metadata. This will be a unique identifier for each indididual (it generally contains datetime, machine name an region id). This will diferenciate animals with the same conditions in the metadata. Adding a column that tracks “how to find the data for each individual”. Take home message In conclusion, metadatafiles are a canonical way to both define experimental condition and load behavioural data. They are both computer and human friendly. In other words, if you give a query to a colaborator, she/he will be able to tell very quickly what animal underwent which treatment, where and when. "],
["behavr.html", "behavr tables Variables and metavariables Operating on behavr tables Playing with toy data Generalities", " behavr tables A single data structure to store data and metadata a behavr table Variables and metavariables As we have seen in the previous section, metadata are crucial for proper statistical analysis of behavioural data. The point of an experiment, is however to acquire data. That is, a long time series of recorded variables such as position, orientation and number of beam crosses, for each individual. Variables are different form metavariables in so far as the latter are made of only one value per animal. It is easier (and less error prone) to always keep the data and metadata together. In rethomics, in order to handle large amounts of data (together with metadata), we have designed the behavr package. behavr tables are based on the very powerful package data.table, but enhanced with metadata. For most purposes, you can use a behavr table just like a data.table. Therefore, have a look at the introduction to data.table further detail! When we load any behavioural data in rethomics, we get a behavr table as a result. In this section, we will discuss the usual operations that you can perform on behavr tables. Operating on behavr tables Now that we have all our data at the same place, we want to be able to manipulate it. In the next part of this tutorial, we will create some toy data and learn how to manipulate it. This table is a short overview: Section Operation Expression Example Generalities Summarise behavr table summary(DT) How many individuals, variables, metavariables, etc? – summary(dt) Pure data Create/alter a variable DT[, new_column := some_value] When are aninimals ‘very active’? – dt[, very_active := activity &gt;= 2] Remove a variable DT[, column_to_delete := NULL] Lets remove a variable we don’t need? – dt[, very_active := NULL] Select data rows DT[criteria] Exclude data before the first hour – small_dt &lt;- dt[t &gt; hours(1)] Pure metadata Access metadata table DT[meta = TRUE] Show metadata as table – dt[meta = TRUE] Create/alter metavariable DT[, new_meta := some_value, meta=TRUE] Define a new factor that is a comibiation of ‘sex x condition’ – dt[, treatment := paste(sex, condition, sep='|'), meta=T] Meta &amp; data Use metavariable as variable xmv(metavariable) Add 10s to all time, only for animals in condition 'A' – dt[, t := ifelse(xmv(condition) == 'A', t + 10, t)] Remove individuals according to metavariable DT[criteria] Remove all males (from data, and metadata) – dt_males &lt;- dt[xmv(sex) == 'females'] Summarise Compute indidisual statistics DT[, .( statistics = some_math()), by='id'] Compute the average activity, per animal – stat_dt &lt;- dt[, .(mean_acti = mean(active)), by='id'] Rejoin metadata to data rejoin(DT) Merge metadata and summary statistics – stat_dt &lt;- rejoin(stat_dt) Advanced Stitch experiments stitch_on(DT, metavariable) TODO – TODO Playing with toy data The behavr package has a set of functions to make toy data. In order to have a look at a behavr object, lets create one. First, we make the metadata: library(behavr) ## Loading required package: data.table metadata &lt;- data.table( id = paste(&quot;toy_experiment&quot;, 1:10, sep = &quot;|&quot;), sex = rep(c(&quot;male&quot;, &quot;female&quot;), each = 5), condition = c(&quot;A&quot;, &quot;B&quot;) ) metadata ## id sex condition ## 1: toy_experiment|1 male A ## 2: toy_experiment|2 male B ## 3: toy_experiment|3 male A ## 4: toy_experiment|4 male B ## 5: toy_experiment|5 male A ## 6: toy_experiment|6 female B ## 7: toy_experiment|7 female A ## 8: toy_experiment|8 female B ## 9: toy_experiment|9 female A ## 10: toy_experiment|10 female B Then, we use toy_dam_data() to simulate (instead of linking/loading) one day of DAMS-like data for these ten animals (and two conditions): dt &lt;- toy_dam_data(metadata, duration = days(1)) dt ## ## ==== METADATA ==== ## ## id sex condition ## &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|1 male A ## 2: toy_experiment|10 female B ## 3: toy_experiment|2 male B ## 4: toy_experiment|3 male A ## 5: toy_experiment|4 male B ## 6: toy_experiment|5 male A ## 7: toy_experiment|6 female B ## 8: toy_experiment|7 female A ## 9: toy_experiment|8 female B ## 10: toy_experiment|9 female A ## ## ====== DATA ====== ## ## id t activity ## &lt;char&gt; &lt;num&gt; &lt;int&gt; ## 1: toy_experiment|1 0 0 ## 2: toy_experiment|1 60 2 ## 3: toy_experiment|1 120 0 ## 4: toy_experiment|1 180 1 ## --- ## 14406: toy_experiment|9 86160 0 ## 14407: toy_experiment|9 86220 0 ## 14408: toy_experiment|9 86280 2 ## 14409: toy_experiment|9 86340 1 ## 14410: toy_experiment|9 86400 0 As you can see, when we print dt, our behavr table, we have two fields: METADATA and DATA. The former is actually just the metadata we created whilst the latter stores the data (i.e. the variables) for all animals. The special column id is also known as a key, and is shared between both data and metadata. It inernally allows us to map them to one another. In other words, it is a unique id for each individual. In this specific example, the variables t and activity are the time and the number of beam crosses, respectively. Generalities A quick way to retreive general information about a behavr table is to use summary: summary(dt) ## behavr table with: ## 10 individuals ## 2 metavariables ## 2 variables ## 1.441e+04 measurements ## 1 key (id) This tells us immediately how many variables, metavariables and data points, we have. One can also print a detailed summary (i.e. one per animal): summary(dt, detailed = TRUE) ## ## Summary of each individual (one per row): ## id sex condition data_points time_range ## 1: toy_experiment|1 male A 1441 [0 -&gt; 86400 (86400)] ## 2: toy_experiment|10 female B 1441 [0 -&gt; 86400 (86400)] ## 3: toy_experiment|2 male B 1441 [0 -&gt; 86400 (86400)] ## 4: toy_experiment|3 male A 1441 [0 -&gt; 86400 (86400)] ## 5: toy_experiment|4 male B 1441 [0 -&gt; 86400 (86400)] ## 6: toy_experiment|5 male A 1441 [0 -&gt; 86400 (86400)] ## 7: toy_experiment|6 female B 1441 [0 -&gt; 86400 (86400)] ## 8: toy_experiment|7 female A 1441 [0 -&gt; 86400 (86400)] ## 9: toy_experiment|8 female B 1441 [0 -&gt; 86400 (86400)] ## 10: toy_experiment|9 female A 1441 [0 -&gt; 86400 (86400)] Data Playing with variables is just like in data.table. Read the official data.table tutorial for more functionalities. For instance, we can add a new variable, very_active, that is TRUE if and only if there was at least two beam crosses in a minute, for a given individual: dt[, very_active := activity &gt;= 2] If we decide we don’t need this variable anymore, we can remove it: dt[, very_active := NULL] Sometimes, we would like to filter the data. That is, we select rows according to one or several criteria. Often we would lile to exclude thew very start of the experiment. For example, we can keep data after one hour: dt &lt;- dt[ t &gt; hours(1)] Note that that using dt &lt;- mean we make a new table that overwrite the old one (since it has the same name). Metadata In order to access the metadata, we can add meta = TRUE inside the []: dt[meta = TRUE] ## id sex condition ## 1: toy_experiment|1 male A ## 2: toy_experiment|10 female B ## 3: toy_experiment|2 male B ## 4: toy_experiment|3 male A ## 5: toy_experiment|4 male B ## 6: toy_experiment|5 male A ## 7: toy_experiment|6 female B ## 8: toy_experiment|7 female A ## 9: toy_experiment|8 female B ## 10: toy_experiment|9 female A This way, we can also create new metavariables. For instance, say you want to collapse sex and condition which both have two levels into one treatment, with four levels: dt[, treatment := paste(sex, condition, sep=&#39;|&#39;), meta=T] # just to show the result: dt[meta = TRUE] ## id sex condition treatment ## 1: toy_experiment|1 male A male|A ## 2: toy_experiment|10 female B female|B ## 3: toy_experiment|2 male B male|B ## 4: toy_experiment|3 male A male|A ## 5: toy_experiment|4 male B male|B ## 6: toy_experiment|5 male A male|A ## 7: toy_experiment|6 female B female|B ## 8: toy_experiment|7 female A female|A ## 9: toy_experiment|8 female B female|B ## 10: toy_experiment|9 female A female|A Data &amp; Metadata The strength of behavr tables is their ability to seamlessly use metavariables as though they were variables. For the sake of the example, lets say you would like to alter the variable t (time) so that we add ten seconds, only to individuals that have condition 'A'. dt[, t := ifelse(xmv(condition) == &#39;A&#39;, t + 10, t)] The key here is the use of xmv (eXpand MetaVariable), which maps condition back in the data. We can also use this mechanism to remove individual according to the value of a metavariable. For instance, lets get rid of the males! dt &lt;- dt[xmv(sex) == &#39;female&#39;] summary(dt) ## behavr table with: ## 5 individuals ## 3 metavariables ## 2 variables ## 6.9e+03 measurements ## 1 key (id) When individuals are removed, metadata is automatically updated. In effect, we removed males from both data and metadata. Summerise data Thanks to data table by operations, it is simple and efficient to compute statistics per individual. For instance, we may want to compute the average activity for each animal: stat_dt &lt;- dt[, .(mean_acti = mean(activity)), by=&#39;id&#39;] stat_dt ## ## ==== METADATA ==== ## ## id sex condition treatment ## &lt;char&gt; &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|10 female B female|B ## 2: toy_experiment|6 female B female|B ## 3: toy_experiment|7 female A female|A ## 4: toy_experiment|8 female B female|B ## 5: toy_experiment|9 female A female|A ## ## ====== DATA ====== ## ## id mean_acti ## &lt;char&gt; &lt;num&gt; ## 1: toy_experiment|10 0.4420290 ## 2: toy_experiment|6 0.1615942 ## 3: toy_experiment|7 0.4434783 ## 4: toy_experiment|8 0.1731884 ## 5: toy_experiment|9 0.2550725 You can actually compute many variables in one go this way: stat_dt &lt;- dt[, .(mean_acti = mean(activity), max_acti = max(activity) ), by=&#39;id&#39;] stat_dt ## ## ==== METADATA ==== ## ## id sex condition treatment ## &lt;char&gt; &lt;char&gt; &lt;char&gt; &lt;char&gt; ## 1: toy_experiment|10 female B female|B ## 2: toy_experiment|6 female B female|B ## 3: toy_experiment|7 female A female|A ## 4: toy_experiment|8 female B female|B ## 5: toy_experiment|9 female A female|A ## ## ====== DATA ====== ## ## id mean_acti max_acti ## &lt;char&gt; &lt;num&gt; &lt;int&gt; ## 1: toy_experiment|10 0.4420290 3 ## 2: toy_experiment|6 0.1615942 2 ## 3: toy_experiment|7 0.4434783 3 ## 4: toy_experiment|8 0.1731884 2 ## 5: toy_experiment|9 0.2550725 2 Now, in order to perform statistics, we would lke to merge our summaries to the metadata. That is we want to rejoin them: final_dt &lt;- rejoin(stat_dt) final_dt ## id sex condition treatment mean_acti max_acti ## 1: toy_experiment|10 female B female|B 0.4420290 3 ## 2: toy_experiment|6 female B female|B 0.1615942 2 ## 3: toy_experiment|7 female A female|A 0.4434783 3 ## 4: toy_experiment|8 female B female|B 0.1731884 2 ## 5: toy_experiment|9 female A female|A 0.2550725 2 This table is exactly what you need for statistcis and vidualisation in R! Stitching TODO "],
["dam-sleep.html", "Sleep analysis with DAM data Background Downloading tutorial data Metadata", " Sleep analysis with DAM data Step-by-step example of analysis of sleep and circadian rhythm from DAM2 data A Drosophila Activity Monitor Background Drosophila Activity Monitors (DAMs) are a wildely used tool to monitor activity of fruit flies over several days. I am assuming that, if you are reading this tutorial, you are already familiar with the system, but I will make a few point clear before we start something more hands-on: This tutorial is about single beam DAM2 We work with the raw data (the data from each monitor is in one signe file, and all the monitor files are in the same folder) Downloading tutorial data First of all, lets get the data I put together for this tutorial. What the data is…: Experiments Unzip the data Metadata As we discussed in the previous sesion "],
["etho-sleep.html", "Sleep analysis with ethoscope", " Sleep analysis with ethoscope "],
["ggetho.html", "Visualisation with ggetho Lessons from ggplot Some behavioural data The ggetho() function Tile plots Population plots Wrapping data LD annotations Coordinate and scales Miscelaneous", " Visualisation with ggetho Make the most of ggetho Lessons from ggplot In the previous tutorials, we have used ggetho to visualise out behavioural data. This section will explain further how this package can be used to produce flexible plots and how it integrates with ggplot2. ggplot2 is one of the most popular visualisation tool and an unavoidable R package. It implements the powerful concepts of the “Grammar of graphics”. The package ggetho, which we discuss here, extends ggplot for the specific case of behavioural analysis. At this stage, you really want to have some familiarity with ggplot2 so you understand its logic. You will find a fair numbers of videos and books online. Some behavioural data In this section, we will simulate toy behavioural data. For that, we start by making some arbitrary metadata. Here, we have 40 animals, condition “A” vs “B”, and sex, male (“M”) or female (“F”). library(ggetho) ## Loading required package: ggplot2 metadata &lt;- data.table(id=sprintf(&quot;toy_experiment|%02d&quot; , 1:40), region_id=1:40, condition=c(&quot;A&quot;,&quot;B&quot;), sex=c(&quot;M&quot;,&quot;M&quot;, &quot;F&quot;, &quot;F&quot;)) head(metadata) ## id region_id condition sex ## 1: toy_experiment|01 1 A M ## 2: toy_experiment|02 2 B M ## 3: toy_experiment|03 3 A F ## 4: toy_experiment|04 4 B F ## 5: toy_experiment|05 5 A M ## 6: toy_experiment|06 6 B M dt &lt;- toy_activity_data(metadata, seed=107) Now, we have a behavr object, dt: summary(dt) ## behavr table with: ## 40 individuals ## 3 metavariables ## 3 variables ## 1.72804e+06 measurements ## 1 key (id) This data is stored in a behavr table. It has a column moving that that tells us whether an the animal id is moving at a time t. The ggetho() function ggetho() is the core function. It expresses the relationship between variables. In this respect, it works very much like ggplot(), but it also pre-processes the data. For example if we would like: The proportion of time spent moving, on the y axis Versus time, on the x axis We could write: pl &lt;- ggetho(dt, aes(x=t, y=moving)) pl This generates an empty plot this is normal because we have, so far, no layer. We will see some layers very soon! The role of ggetho is to express a relationship between variables and to compute a summary, over a certain time window, of a variable of interest for each individual. Importantly, you decide which variable you want to plot. For instance, you could be interested in things like the number (sum) of beam crosses or the average position. Tile plots Per individual One of the most interesting layer is stat_tile_etho. It shows the variable of interest in the (colour) z axis. The y axis is discrete (generally the id), and the x axis is time. So, if we want to show the proportion of time spent moving over time for each individual (id): pl &lt;- ggetho(dt, aes(x=t, y=id, z=moving)) + stat_tile_etho() pl By defaut, each pixel is the mean (summary_FUN = mean, in ggetho), over 30 min (summary_time_window = mins(30), in ggetho()). Also, note that the default is x=t and y=id, so we could just obtain exactly the same with ggetho(dt, aes(z=moving)) + stat_tile_etho(). Sorted individual Sometimes, we want to sort individuals based on a metavariable (discrete or continuous). For instance let us compute the overall average fraction of time spent moving, add it to the metadata, to then sort individuals from low to high movers: First, we add a new metavariable (mean_moving): # the average time spent moving per 1000 (rounded) mean_mov_dt &lt;- dt[, .(mean_moving = round(mean(moving) * 1000)), by=id] # join curent meta and the summary table new_meta &lt;- dt[mean_mov_dt, meta=T] # set new metadata setmeta(dt, new_meta) head(dt[meta=T]) ## id region_id condition sex mean_moving ## 1: toy_experiment|01 1 A M 138 ## 2: toy_experiment|02 2 B M 195 ## 3: toy_experiment|03 3 A F 90 ## 4: toy_experiment|04 4 B F 118 ## 5: toy_experiment|05 5 A M 123 ## 6: toy_experiment|06 6 B M 203 Now, we can express a new relationship where we show the interaction between our custom variable and id, on the y axis: pl &lt;- ggetho(dt, aes(x=t, y=interaction(id, mean_moving, sep = &quot; : &quot;), z=moving)) + stat_tile_etho() pl Since we use &quot; : &quot; as a separator, we have, on the y axis, names as &lt;id&gt; : &lt;mean_sleep&gt;. You can extend this concept to sort also by males vs females: pl &lt;- ggetho(dt, aes(x=t, y=interaction(id, mean_moving, sex, sep = &quot; : &quot;), z=moving)) + stat_tile_etho() pl Group averages Sometimes, we also want to aggregate individuals per group. For instance, males average vs females average: pl &lt;- ggetho(dt, aes(x=t, y=sex, z=moving)) + stat_tile_etho() pl In this context, every row is not an individual any more, but a group. The method argument of stat_tile_etho() allows you to use other aggregates (median, max, min, …). Population plots One population The problem with representing a variable on a colour axis is that it is not perceptually comparable, and we cannot make error bars. When the number of groups is not too high, it makes sense to show the variable of interest on the y axis, and then draw lines between consecutive points. For this, we can use the stat_pop_etho() function: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_pop_etho() pl By defaut, the local average and error bars are computed from the mean an standard errors (method = mean_se). You can compute other types of error bars e.g. bootstrap (method = mean_cl_boot). Several populations Often, we want to compare population with respect to a variable. There are different way to split populations. We can, for instance, use a different colour line for different groups: pl &lt;- ggetho(dt, aes(x=t, y=moving, colour=sex)) + stat_pop_etho() pl Another way, is to use ggplot’s faceting system: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_pop_etho() + facet_grid(sex ~ .) pl Of course, you can combine both when you have more than one relevant metavariable: pl &lt;- ggetho(dt, aes(x=t, y=moving, colour = sex)) + stat_pop_etho() + facet_grid( condition ~ .) pl Wrapping data When behaviours are periodic, we sometimes want to average our variable at the same time over consecutive days. In ggetho, we call that time wrapping. It can be done simply with the time_wrap argument. It will work the same for population or tile plots: pl &lt;- ggetho(dt, aes(x=t, y=moving), time_wrap = hours(24)) + stat_pop_etho() pl Note that you do not have to wrap over specifically 24h, you could work different periods. LD annotations Basics In circadian experiments, we often like to add annotations (black and white boxes) to show Dark and Light phases. We have another layer for that: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_pop_etho() + stat_ld_annotations() pl Changing LD colours Sometimes you want different colours to explains, for instance, that days are “subjective”(grey). pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_pop_etho() + stat_ld_annotations(ld_colours = c(&quot;grey&quot;, &quot;black&quot;)) pl LD in the background To put the annotation in the background, we can invert the order of the layers, set the heigh of the annotation to 1 (100%) and add some transparency (alpha = 0.3). We also remove the outline of the boxes: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_ld_annotations(height=1, alpha=0.3, outline = NA) + stat_pop_etho() pl Phase and period Sometimes you want to show annotations with different phases and periods. For instance, here, we shift the LD annotations 1h forward: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_ld_annotations(phase = hours(1)) + stat_pop_etho() pl One can also plot over a period different from 24h, say 20h days: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_ld_annotations(period = hours(20)) + stat_pop_etho() pl Regime change When, you want to indicate a change in regime, say from LD to DD. A simple way is to use multiple layers with explicit start and end points: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + # the default annotation layer stat_ld_annotations() + # on top of it, a second layer that # starts at day 2 thoughout day 5, # and where L colour is grey stat_ld_annotations(x_limits = days(c(2,5)), ld_colours = c(&quot;grey&quot;, &quot;black&quot; )) + stat_pop_etho() pl Coordinate and scales Plot limits As ggetho creates regular ggplot objects, which we can extend. For instance, we can change the scales. For instance, put the y scale as a percentage between 0 and 100: pl &lt;- ggetho(dt, aes(x=t, y=moving)) + stat_pop_etho() + stat_ld_annotations() pl &lt;- pl + scale_y_continuous(limits = c(0,1), labels = scales::percent) pl We can also use the same principle to zoom in a finished plot. E.g. between day one and day two: pl + coord_cartesian(xlim=c(days(1), days(2))) Time scale units By default, ggetho decides the unit of the time axis according to the range of the data. Sometime you want to override this behaviour to force time to be in a specific unit (here hours). Using the plot above, we can add a scale: pl + ggetho::scale_x_hours() ## Scale for &#39;x&#39; is already present. Adding another scale for &#39;x&#39;, which ## will replace the existing scale. R actually warns you since you are replacing the scale. Which is fine (as it is precisely what we wanted)! Coordinate systems Sometimes, it makes sense to use polar coordinates to show data around the clock: pl &lt;- ggetho(dt, aes(x=t, y=moving, colour=sex), time_wrap = days(1)) + stat_ld_annotations(height=.5, alpha=.2, x_limits = c(0, days(1)), outline = NA) + stat_pop_etho(geom = &quot;polygon&quot;, fill=NA) pl + coord_polar() Miscelaneous TODO, list ggplot possibilities: Use other geom annotate change title Axis names "]
]
