[
["index.html", "Rethomics, a framework for high-throughput behaviour analysis in R Introduction", " Rethomics, a framework for high-throughput behaviour analysis in R Quentin Geissmann 2017-09-15 Introduction Only if we share a common data structure can we use a common set of tools The rethomics framework unify behaviour analysis over multiple platforms In the last few years, there has been growing interests in ethomics – that is, the analysis of large behavioural data sets. Many software and hardware solutions have been proposed to record different behavioural variables on several model organisms. Although are many similarities between subsequent analysis and visualisation tools, each method tends to provide its own output format and, in practice, its own, restricted, analysis software. This results in a lot of replicated work but also limits extension and collaboration. Rethomics attempts to unify analysis of behaviour by providing several packages: behavr tables – a flexible and universal structure to handle very large behavioural data sets damr, scopr, … – to load data from DAMS, ethoscopes and others into behavr tables ggetho – based on ggplot2, to produce high-quality representations of behavioural data sleepr, zeitgebr, … – to analyse behavioural data (sleep analysis, circadian rhythm, …) This document is a tutorial intended for experimenters as well as data analysts. It provides a suite of both conceptual explanations and very concrete examples. "],
["intro.html", "First Steps Getting R Installing rethomics packages List of rethomics packages", " First Steps Getting R If you have never used or heard of R before, I suggest you start by reading about data science in R and installing RStudio. Only once you have done can we continue. Installing rethomics packages As of today (2017-09-15), rethomics packages are not on CRAN, the official R package archive yet. Therefore, we will install the developmental version. As a prerequisite, we need to install (once for all) devtools and load it: install.packages(&quot;devtools&quot;) library(devtools) Ensure you have no error messages. Then, we can install some of the rethomics packages. For instance, lets install behavr. install_github(&quot;rethomics/behavr&quot;) In the same way, you could replace behavr by another package. For instance, you could install ggetho with install_github(&quot;rethomics/ggetho&quot;). List of rethomics packages Below is a list of all the rethomics packages as well as their individual PDF documentation, description and build status. Package Doc Description Travis.CI Coverage behavr Canonical Data Structure for Behavioural Data ggetho Visualise High-Throughput Behavioural (i.e. Ethomics) Data damr Read Drosophila Activity Monitor Data scopr Read Ethoscope Data sleepr Analyse Activity and Sleep Behaviour zeitgebr Analyse and Visualise Circadian Behaviours "],
["workflow.html", "The rethomics workflow", " The rethomics workflow From hypothesis to results The rethomics workflow In rethomics, we envisage behavioural experiments as a workflow: Design – you plan your experiment (I can’t really help you with that, but I trust you!). Record/track – you use your acquisition platfrom to record behavioural variables over time. They define the format of the results. Write individual information – you make a spreadsheet (CSV file) that details the experimental conditions for each individual. We call this a metadata file. It is a crucial concept in rethomics, so we will dedicate it the next section. You can often write your metadata as you plan your experiment, but sometimes, you want to enrich it with variables that you can only record after your experiment (e.g. lifespan). Link and Load data – First, we enrich your metadata by “linking” it to the result. This allows you to load all the matching data into a singlebehavr table (see section on behavr tables). Tranform &amp; analyse &amp; visualise – you take advantage of rethomics and R analysis and visualisation tools. "],
["metadata.html", "Working with metadata files What are metadata? Make them exhaustive Put replicates together Linking metadata Take home message", " Working with metadata files Using and understanding metadata files makes your analyses more transparent and tracktable Schematic of a metadata file What are metadata? When performing many experiments, with multiple condidions and replicates, it becomes challenging to keep track of each individual and to link it to its actual data. In rethomics, regardless of the tool used to generate data, loading results always involves a metadata file. It is, in fact, a simple CSV file (basically a spreadsheet) in which each row defines one unique individual. As shown in the figure above, queries contain two types of columns: Mandatory techincal columns – for instance date, machine_name and others (depending on the acquisition platform). They will be used to match an animal to its data. Optional experimental columns – in this example, condition and sex. You can use as all the columns you want to characterise your experiments. Make them exhaustive It is a good habit to record as much information as possible in our metadata – even if it seems redundant. For instance, if we put animal in different incubators, we can simply add an incubator column. This way, we keep all our experimental notes, as much as possible, inside one file. Not only this will help us to “debug” if anything goes wrong in one incubator, but we will also be able to account for incubator as a covariate later on. From a computational perspective, these columns are virtually free. Put replicates together A common mistake for users is to perform several replicates of the same experiment and to make a new metadata file each time. Instead, I strongly recommand you to put all replicates in the same file. If it helps, you can add a replicate column so you can keep track of which replicate each animal comes from. The whole point of high-througput analysis is that you can load all the data from all replicates and compare it (and maybe merge it). The bottom line is that, if you start form a single metadata file, your work will be more tracktable, and you can always decide to analyse only one replicate at a time. Linking metadata Linking adds technical columns Once your metadata is ready, it can be used as a query to import the matching data. Regardless of which acquisition tool you used, the first step when importing data in R will be “metadata linking”. In short, linking means at least: Adding an id column to the metadata. This will be a unique identifier for each indididual (it generally contains datetime, machine name an region id) Adding a column that tracks “how to find the data for each individual” Take home message In conclusion, metadatafiles are a canonical way to both define experimental condition and load behavioural data. They are both computer and human friendly. In other words, if you give a query to a colaborator, she/he will be able to tell very quickly what animal underwent which treatment, where and when. "],
["behavr.html", "behavr tables Variables and metavariables Toy data Operating on behavr tables", " behavr tables Variables and metavariables When performing behavioural experiments, many animals are individually monitored. For each of these individual, we record a set of variables (e.g. position, orientation, beam breaking,…). Each variable is recorded at successive intervals, over long durations. In addition to these variables, which change over time we also have metavariables. Metavariables contain information about each individual. This information can be defined (or recorded) before or after the experiment, but in all cases the point is that it does not change over time (e.g. treatment, genotype, lifespan). Typically, metavariables are defined as extra columns a the metadata file, but they can also be computed. For example, if we recorded x and y positions over time, for animals of different sex and genotype, x and y would be the variables whilst sex and genotype would be the metavariables. Regardless to what device was used to generate our data and how we loaded it, in rethomics, we will always have data and metadata linked together. In order to handle efficiently large amounts of data (toghter with metadata), we have designed the behavr package. A behavr table is essentially a data.table enhanced with metadata. When we load any behavioural data in rethomics, we get a behavr table as a result. Therefore, it is important to understand how to manipulate and operate on this data structure. Toy data The behavr package has a set of functions to make toy data. In order to have a look at a behavr object, lets create one. First, we make the metadata: library(behavr) metadata &lt;- data.frame( experiment_id = &quot;toy_experiment&quot;, region_id = 1:10, condition = c(&quot;A&quot;, &quot;B&quot;) ) metadata ## experiment_id region_id condition ## 1 toy_experiment 1 A ## 2 toy_experiment 2 B ## 3 toy_experiment 3 A ## 4 toy_experiment 4 B ## 5 toy_experiment 5 A ## 6 toy_experiment 6 B ## 7 toy_experiment 7 A ## 8 toy_experiment 8 B ## 9 toy_experiment 9 A ## 10 toy_experiment 10 B Then, we use toy_dam_data() to simulate one day of DAMS-like data for these ten animals (and two conditions): dt &lt;- toy_dam_data(metadata, duration = days(1)) dt ## ## ==== METADATA ==== ## ## id experiment_id region_id condition ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B ## ## ====== DATA ====== ## ## id t activity ## &lt;fctr&gt; &lt;num&gt; &lt;int&gt; ## 1: 01|toy_experiment 0 0 ## 2: 01|toy_experiment 60 2 ## 3: 01|toy_experiment 120 0 ## 4: 01|toy_experiment 180 1 ## --- ## 14406: 10|toy_experiment 86160 0 ## 14407: 10|toy_experiment 86220 0 ## 14408: 10|toy_experiment 86280 2 ## 14409: 10|toy_experiment 86340 1 ## 14410: 10|toy_experiment 86400 0 As you can see, when we print dt, our behavr table, we have two fields: METADATA and DATA. The former has only one row per animal and looks very much like metadata, with an extra column named id. The later is the actual data of all animals. The special column id is also known as a key. It allows to map data to metadata. In other words, there is a unique id for each individual. In this specific example, t is the time and activity is the number of beam crosses. A quick way to retreive general information about a behavr table is to use summary: summary(dt) ## behavr table with: ## 10 individuals ## 3 metavariables ## 2 variables ## 1.441e+04 measurements ## 1 key (id) This tells us immediately how many variables and metavariables we have. It also tells us when are the first and last recording for each animal. Operating on behavr tables Variables Playing with variables is just like in data.table. Read the official data.table tutorial for more functionalities. For instance, we can add a new variable, very_active that is TRUE if and only if there was at least two beam crosses in a minute: dt[, very_active := activity &gt;= 2] One can also filter data. For instance, we want to show only point before three hours: dt[t &lt; hours(3)] ## ## ==== METADATA ==== ## ## id experiment_id region_id condition ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B ## ## ====== DATA ====== ## ## id t activity very_active ## &lt;fctr&gt; &lt;num&gt; &lt;int&gt; &lt;lgcl&gt; ## 1: 01|toy_experiment 0 0 FALSE ## 2: 01|toy_experiment 60 2 TRUE ## 3: 01|toy_experiment 120 0 FALSE ## 4: 01|toy_experiment 180 1 FALSE ## --- ## 1796: 10|toy_experiment 10500 0 FALSE ## 1797: 10|toy_experiment 10560 1 FALSE ## 1798: 10|toy_experiment 10620 0 FALSE ## 1799: 10|toy_experiment 10680 0 FALSE ## 1800: 10|toy_experiment 10740 0 FALSE Note that hours(3) just converts 3h in seconds, because time is expressed in seconds in rethomics (there is also a days() and a mins() function). Expand metavariables Sometimes, you would like to use metavariables as if they were variables. Imagine, for instance, that we want to correct activity according to the condition, say we need to multiply activity by two for condition “A”. For this purpoe, we can use the function xmv (eXpand MetaVariable): dt[, activity_corrected := ifelse(xmv(condition) == &quot;A&quot;, activity * 2, activity)] If condition were a variable, we would use ifelse(condition == &quot;A&quot;, activity * 2, activity). Since it is in metadata, we just replace condition by xmv(condition). Metadata The Metadata is itself a table. To perform operations on metadata, on can use meta=TRUE inside the [] operator. For intace, only to display the metadata: dt[meta=TRUE] ## id experiment_id region_id condition ## 1: 01|toy_experiment toy_experiment 1 A ## 2: 02|toy_experiment toy_experiment 2 B ## 3: 03|toy_experiment toy_experiment 3 A ## 4: 04|toy_experiment toy_experiment 4 B ## 5: 05|toy_experiment toy_experiment 5 A ## 6: 06|toy_experiment toy_experiment 6 B ## 7: 07|toy_experiment toy_experiment 7 A ## 8: 08|toy_experiment toy_experiment 8 B ## 9: 09|toy_experiment toy_experiment 9 A ## 10: 10|toy_experiment toy_experiment 10 B We can use the same principle to add new metavariable: dt[, my_new_column := interaction(region_id, condition), meta=TRUE] dt[meta=TRUE] ## id experiment_id region_id condition my_new_column ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B Summarise data At some point, we will want to compute one or several summary variables for each animal and, for instance, model these versus metavariable. For instance, we could compute the sum of all activity for each animal. Since each animal is identified by its id, we use by=id for this: summary_dt &lt;- dt[, .(sum_activity = sum(activity)), by=id] summary_dt ## ## ==== METADATA ==== ## ## id experiment_id region_id condition my_new_column ## &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B ## ## ====== DATA ====== ## ## id sum_activity ## &lt;fctr&gt; &lt;int&gt; ## 1: 01|toy_experiment 375 ## 2: 02|toy_experiment 682 ## 3: 03|toy_experiment 737 ## 4: 04|toy_experiment 324 ## 5: 05|toy_experiment 647 ## 6: 06|toy_experiment 741 ## 7: 07|toy_experiment 247 ## 8: 08|toy_experiment 683 ## 9: 09|toy_experiment 263 ## 10: 10|toy_experiment 389 Now, the data is only one point per animal, with id, and our new variable. We aggreated the data, so it is quite managable to put the summary data and the metadata in the same table. For that, we use rejoin: r final_dt &lt;- rejoin(summary_dt) final_dt ## id experiment_id region_id condition my_new_column ## 1: 01|toy_experiment toy_experiment 1 A 1.A ## 2: 02|toy_experiment toy_experiment 2 B 2.B ## 3: 03|toy_experiment toy_experiment 3 A 3.A ## 4: 04|toy_experiment toy_experiment 4 B 4.B ## 5: 05|toy_experiment toy_experiment 5 A 5.A ## 6: 06|toy_experiment toy_experiment 6 B 6.B ## 7: 07|toy_experiment toy_experiment 7 A 7.A ## 8: 08|toy_experiment toy_experiment 8 B 8.B ## 9: 09|toy_experiment toy_experiment 9 A 9.A ## 10: 10|toy_experiment toy_experiment 10 B 10.B ## sum_activity ## 1: 375 ## 2: 682 ## 3: 737 ## 4: 324 ## 5: 647 ## 6: 741 ## 7: 247 ## 8: 683 ## 9: 263 ## 10: 389 This table is now perfectly suited for further statistical analysis and visualisation! Stitching TODO "]
]
